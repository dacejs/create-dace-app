import React from 'react';
import { StaticRouter } from 'react-router-dom';
import { matchRoutes, renderRoutes } from 'react-router-config';
import { renderToString } from 'react-dom/server';
import { ChunkExtractor } from '@loadable/server';
import { Helmet } from 'react-helmet';
import { Provider } from 'react-redux';
import serialize from 'serialize-javascript';
import { RedBoxError } from 'redbox-react';
import routes from 'dace/dist/runtime/ssrRoutes';
import createStore from 'dace-plugin-redux/dist/runtime/createStore';
import document from 'dace/dist/runtime/document';
import { increment, timing } from '../utils/watcher';

export default async (req, res) => {
  const startTime = new Date();
  const store = createStore(req);
  // 查找当前 URL 匹配的路由
  const { query, _parsedUrl: { pathname } } = req;
  const branch = matchRoutes(routes, pathname);
  // 匹配的最后一个组件是 `NotFound` 的话，表示地址不存在
  const notFound = branch[branch.length - 1].route.component.name === 'NotFound';

  // 页面名称
  // 通过 @getInitialProps 装饰器将页面名称传递过来
  let metric;

  if (notFound) {
    res.status(404).end();
  } else {
    const promises = branch // <- react-router 不匹配 querystring
      .map(async ({ route, match }) => {
        const { component } = route;
        if (component && component.load && typeof component.load === 'function') {
          // 预加载 @loadable/component
          // 确保服务器端第一次渲染时能拿到数据
          const AsyncComponent = (await component.load()).default;

          // 获取页面名称，用于 watcher 打点
          // 所有页面的打点放到 appcode.pages.xxx
          metric = AsyncComponent.pageName;
          if (metric) {
            metric = `pages.${metric}`;
          }

          // 服务器端获取页面初始化所需的数据
          if (AsyncComponent.getInitialProps) {
            const ctx = {
              match,
              store,
              query,
              req,
              res
            };
            const props = await AsyncComponent.getInitialProps(ctx);
            return props;
          }
        }
        return null;
      })
      .filter(Boolean);

    const getInitialPropsStartTime = new Date();
    // 执行 getInitialProps ，在此之后的 store 中将包含数据
    await Promise.all(promises);
    if (metric) {
      timing(`${metric}.getInitialProps`, getInitialPropsStartTime);
    }

    const context = {};
    const Markup = (
      <Provider store={store}>
        <StaticRouter context={context} location={req.url}>
          {renderRoutes(routes, { store })}
        </StaticRouter>
      </Provider>
    );

    // This is the stats file generated by webpack loadable plugin
    // eslint-disable-next-line global-require
    const stats = require(process.env.DACE_PATH_LOADABLE_STATS_JSON);
    // We create an extractor from the statsFile
    const extractor = new ChunkExtractor({ stats });
    // Wrap your application using "collectChunks"
    const jsx = extractor.collectChunks(Markup);

    let markup;
    let scriptTags;
    let styleTags;
    try {
      const renderToStringStartTime = new Date();
      markup = renderToString(jsx);
      if (metric) {
        timing(`${metric}.renderToString`, renderToStringStartTime);
      }
      scriptTags = extractor.getScriptTags();
      styleTags = extractor.getStyleTags();
    } catch (error) {
      res.status(500);
      if (metric) {
        increment(`${metric}.error`);
      }
      markup = renderToString(process.env.NODE_ENV !== 'production' ? <RedBoxError error={error} /> : <div>抱歉，服务器正忙，请稍候再试。</div>);
    }

    // renderStatic 需要在 root 元素 renderToString 后执行
    const head = Helmet.renderStatic();
    const state = serialize(store.getState());
    const html = document({
      head,
      markup,
      state,
      styleTags,
      scriptTags
    });
    res.status(200).send(html);
    if (metric) {
      increment(metric);
      timing(metric, startTime);
    }
  }
};
